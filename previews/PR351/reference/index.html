<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · LinearOperators.jl</title><meta name="title" content="Reference · LinearOperators.jl"/><meta property="og:title" content="Reference · LinearOperators.jl"/><meta property="twitter:title" content="Reference · LinearOperators.jl"/><meta name="description" content="Documentation for LinearOperators.jl."/><meta property="og:description" content="Documentation for LinearOperators.jl."/><meta property="twitter:description" content="Documentation for LinearOperators.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LinearOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LinearOperators.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Base.Matrix-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T"><code>Base.Matrix</code></a></li><li><a href="#LinearAlgebra.Hermitian"><code>LinearAlgebra.Hermitian</code></a></li><li><a href="#LinearAlgebra.Symmetric"><code>LinearAlgebra.Symmetric</code></a></li><li><a href="#LinearOperators.DiagonalAndrei"><code>LinearOperators.DiagonalAndrei</code></a></li><li><a href="#LinearOperators.DiagonalAndrei-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>LinearOperators.DiagonalAndrei</code></a></li><li><a href="#LinearOperators.DiagonalPSB"><code>LinearOperators.DiagonalPSB</code></a></li><li><a href="#LinearOperators.DiagonalPSB-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>LinearOperators.DiagonalPSB</code></a></li><li><a href="#LinearOperators.LBFGSData"><code>LinearOperators.LBFGSData</code></a></li><li><a href="#LinearOperators.LBFGSOperator"><code>LinearOperators.LBFGSOperator</code></a></li><li><a href="#LinearOperators.LBFGSOperator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer"><code>LinearOperators.LBFGSOperator</code></a></li><li><a href="#LinearOperators.LSR1Data"><code>LinearOperators.LSR1Data</code></a></li><li><a href="#LinearOperators.LSR1Operator"><code>LinearOperators.LSR1Operator</code></a></li><li><a href="#LinearOperators.LSR1Operator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer"><code>LinearOperators.LSR1Operator</code></a></li><li><a href="#LinearOperators.LinearOperator"><code>LinearOperators.LinearOperator</code></a></li><li><a href="#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Symmetric{T, S} where S&lt;:(AbstractMatrix{&lt;:T})}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S} where S&lt;:(AbstractMatrix{&lt;:T}), Any}} where T&lt;:Real"><code>LinearOperators.LinearOperator</code></a></li><li><a href="#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.SymTridiagonal{T, V} where V&lt;:AbstractVector{T}}, Tuple{T}, Tuple{LinearAlgebra.SymTridiagonal{T, V} where V&lt;:AbstractVector{T}, Any}} where T"><code>LinearOperators.LinearOperator</code></a></li><li><a href="#LinearOperators.LinearOperator-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>LinearOperators.LinearOperator</code></a></li><li><a href="#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T})}, Tuple{T}, Tuple{LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T}), Any}} where T"><code>LinearOperators.LinearOperator</code></a></li><li><a href="#LinearOperators.LinearOperator-Union{Tuple{I}, Tuple{T}, Tuple{Type{T}, I, I, Bool, Bool, Any}, Tuple{Type{T}, I, I, Bool, Bool, Any, Any}, Tuple{Type{T}, I, I, Bool, Bool, Any, Any, Any}} where {T, I&lt;:Integer}"><code>LinearOperators.LinearOperator</code></a></li><li><a href="#LinearOperators.SpectralGradient-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:Real, I&lt;:Integer}"><code>LinearOperators.SpectralGradient</code></a></li><li><a href="#LinearOperators.SpectralGradient"><code>LinearOperators.SpectralGradient</code></a></li><li><a href="#LinearOperators.TimedLinearOperator-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T"><code>LinearOperators.TimedLinearOperator</code></a></li><li><a href="#LinearOperators.opEye"><code>LinearOperators.opEye</code></a></li><li><a href="#LinearOperators.opEye-Tuple{DataType, Int64}"><code>LinearOperators.opEye</code></a></li><li><a href="#LinearOperators.opEye-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer"><code>LinearOperators.opEye</code></a></li><li><a href="#Base.kron-Tuple{AbstractLinearOperator, AbstractLinearOperator}"><code>Base.kron</code></a></li><li><a href="#Base.push!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{I}, Tuple{T}, Tuple{LBFGSOperator{T, I, F1, F2, F3}, Vector{T}, Vector{T}}} where {T, I, F1, F2, F3}"><code>Base.push!</code></a></li><li><a href="#Base.push!-Tuple{LSR1Operator, AbstractVector, AbstractVector}"><code>Base.push!</code></a></li><li><a href="#Base.show-Tuple{IO, AbstractLinearOperator}"><code>Base.show</code></a></li><li><a href="#Base.size-Tuple{AbstractLinearOperator, Integer}"><code>Base.size</code></a></li><li><a href="#Base.size-Tuple{AbstractLinearOperator}"><code>Base.size</code></a></li><li><a href="#LinearAlgebra.diag-Union{Tuple{LBFGSOperator{T}}, Tuple{T}} where T"><code>LinearAlgebra.diag</code></a></li><li><a href="#LinearAlgebra.diag-Union{Tuple{LSR1Operator{T}}, Tuple{T}} where T"><code>LinearAlgebra.diag</code></a></li><li><a href="#LinearAlgebra.ishermitian-Tuple{AbstractLinearOperator}"><code>LinearAlgebra.ishermitian</code></a></li><li><a href="#LinearAlgebra.issymmetric-Tuple{AbstractLinearOperator}"><code>LinearAlgebra.issymmetric</code></a></li><li><a href="#LinearOperators.BlockDiagonalOperator-Tuple"><code>LinearOperators.BlockDiagonalOperator</code></a></li><li><a href="#LinearOperators.InverseLBFGSOperator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer"><code>LinearOperators.InverseLBFGSOperator</code></a></li><li><a href="#LinearOperators.check_ctranspose-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}"><code>LinearOperators.check_ctranspose</code></a></li><li><a href="#LinearOperators.check_hermitian-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}"><code>LinearOperators.check_hermitian</code></a></li><li><a href="#LinearOperators.check_positive_definite-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}"><code>LinearOperators.check_positive_definite</code></a></li><li><a href="#LinearOperators.has_args5-Tuple{AbstractLinearOperator}"><code>LinearOperators.has_args5</code></a></li><li><a href="#LinearOperators.normest"><code>LinearOperators.normest</code></a></li><li><a href="#LinearOperators.opCholesky-Tuple{AbstractMatrix}"><code>LinearOperators.opCholesky</code></a></li><li><a href="#LinearOperators.opDiagonal-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>LinearOperators.opDiagonal</code></a></li><li><a href="#LinearOperators.opDiagonal-Union{Tuple{I}, Tuple{T}, Tuple{I, I, AbstractVector{T}}} where {T, I&lt;:Integer}"><code>LinearOperators.opDiagonal</code></a></li><li><a href="#LinearOperators.opExtension-Union{Tuple{I}, Tuple{AbstractVector{I}, I}} where I&lt;:Integer"><code>LinearOperators.opExtension</code></a></li><li><a href="#LinearOperators.opHermitian-Tuple{AbstractMatrix}"><code>LinearOperators.opHermitian</code></a></li><li><a href="#LinearOperators.opHermitian-Union{Tuple{T}, Tuple{S}, Tuple{AbstractVector{S}, AbstractMatrix{T}}} where {S, T}"><code>LinearOperators.opHermitian</code></a></li><li><a href="#LinearOperators.opHouseholder-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>LinearOperators.opHouseholder</code></a></li><li><a href="#LinearOperators.opInverse-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>LinearOperators.opInverse</code></a></li><li><a href="#LinearOperators.opLDL"><code>LinearOperators.opLDL</code></a></li><li><a href="#LinearOperators.opOnes-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer"><code>LinearOperators.opOnes</code></a></li><li><a href="#LinearOperators.opRestriction-Union{Tuple{I}, Tuple{AbstractVector{I}, I}} where I&lt;:Integer"><code>LinearOperators.opRestriction</code></a></li><li><a href="#LinearOperators.opZeros-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer"><code>LinearOperators.opZeros</code></a></li><li><a href="#LinearOperators.reset!-Union{Tuple{AbstractDiagonalQuasiNewtonOperator{T}}, Tuple{T}} where T&lt;:Real"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.reset!-Tuple{LSR1Operator}"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.reset!-Union{Tuple{I}, Tuple{T}, Tuple{LinearOperators.LBFGSData{T, I}, Bool}} where {T, I&lt;:Integer}"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.reset!-Tuple{AbstractLinearOperator}"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.reset!-Tuple{LBFGSOperator}"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.reset!-Union{Tuple{LinearOperators.LSR1Data{T, I}}, Tuple{I}, Tuple{T}} where {T, I&lt;:Integer}"><code>LinearOperators.reset!</code></a></li><li><a href="#LinearOperators.solve_shifted_system!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{I}, Tuple{T}, Tuple{AbstractVector{T}, LBFGSOperator{T, I, F1, F2, F3}, AbstractVector{T}, T}} where {T, I, F1, F2, F3}"><code>LinearOperators.solve_shifted_system!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T" href="#Base.Matrix-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A = Matrix(op)</code></pre><p>Materialize an operator as a dense array using <code>op.ncol</code> products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L268-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Hermitian" href="#LinearAlgebra.Hermitian"><code>LinearAlgebra.Hermitian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hermitian(op, uplo=:U)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L219-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Symmetric" href="#LinearAlgebra.Symmetric"><code>LinearAlgebra.Symmetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Symmetric(op, uplo=:U)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L237-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.DiagonalAndrei" href="#LinearOperators.DiagonalAndrei"><code>LinearOperators.DiagonalAndrei</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalAndrei(d)</code></pre><p>Construct a linear operator that represents a diagonal quasi-Newton approximation as described in</p><p>Andrei, N. A diagonal quasi-Newton updating method for unconstrained optimization. https://doi.org/10.1007/s11075-018-0562-7</p><p>The approximation satisfies the weak secant equation and is not guaranteed to be positive definite.</p><p><strong>Arguments</strong></p><ul><li><code>d::AbstractVector</code>: initial diagonal approximation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L82-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.DiagonalAndrei-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#LinearOperators.DiagonalAndrei-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>LinearOperators.DiagonalAndrei</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalAndrei(d)</code></pre><p>Construct a linear operator that represents a diagonal quasi-Newton approximation as described in</p><p>Andrei, N. A diagonal quasi-Newton updating method for unconstrained optimization. https://doi.org/10.1007/s11075-018-0562-7</p><p>The approximation satisfies the weak secant equation and is not guaranteed to be positive definite.</p><p><strong>Arguments</strong></p><ul><li><code>d::AbstractVector</code>: initial diagonal approximation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L82-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.DiagonalPSB" href="#LinearOperators.DiagonalPSB"><code>LinearOperators.DiagonalPSB</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalPSB(d)</code></pre><p>Construct a linear operator that represents a diagonal PSB quasi-Newton approximation as described in</p><p>M. Zhu, J. L. Nazareth and H. Wolkowicz The Quasi-Cauchy Relation and Diagonal Updating. SIAM Journal on Optimization, vol. 9, number 4, pp. 1192-1204, 1999. https://doi.org/10.1137/S1052623498331793.</p><p>The approximation satisfies the weak secant equation and is not guaranteed to be positive definite.</p><p><strong>Arguments</strong></p><ul><li><code>d::AbstractVector</code>: initial diagonal approximation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.DiagonalPSB-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#LinearOperators.DiagonalPSB-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>LinearOperators.DiagonalPSB</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiagonalPSB(d)</code></pre><p>Construct a linear operator that represents a diagonal PSB quasi-Newton approximation as described in</p><p>M. Zhu, J. L. Nazareth and H. Wolkowicz The Quasi-Cauchy Relation and Diagonal Updating. SIAM Journal on Optimization, vol. 9, number 4, pp. 1192-1204, 1999. https://doi.org/10.1137/S1052623498331793.</p><p>The approximation satisfies the weak secant equation and is not guaranteed to be positive definite.</p><p><strong>Arguments</strong></p><ul><li><code>d::AbstractVector</code>: initial diagonal approximation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LBFGSData" href="#LinearOperators.LBFGSData"><code>LinearOperators.LBFGSData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A data type to hold information relative to LBFGS operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LBFGSOperator" href="#LinearOperators.LBFGSOperator"><code>LinearOperators.LBFGSOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A type for limited-memory BFGS approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LBFGSOperator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer" href="#LinearOperators.LBFGSOperator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer"><code>LinearOperators.LBFGSOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LBFGSOperator(T, n; [mem=5, scaling=true])
LBFGSOperator(n; [mem=5, scaling=true])</code></pre><p>Construct a limited-memory BFGS approximation in forward form. If the type <code>T</code> is omitted, then <code>Float64</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LSR1Data" href="#LinearOperators.LSR1Data"><code>LinearOperators.LSR1Data</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A data type to hold information relative to LSR1 operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LSR1Operator" href="#LinearOperators.LSR1Operator"><code>LinearOperators.LSR1Operator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A type for limited-memory SR1 approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LSR1Operator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer" href="#LinearOperators.LSR1Operator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer"><code>LinearOperators.LSR1Operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LSR1Operator(T, n; [mem=5, scaling=false)
LSR1Operator(n; [mem=5, scaling=false)</code></pre><p>Construct a limited-memory SR1 approximation in forward form. If the type <code>T</code> is omitted, then <code>Float64</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LinearOperator" href="#LinearOperators.LinearOperator"><code>LinearOperators.LinearOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Base type to represent a linear operator. The usual arithmetic operations may be applied to operators to combine or otherwise alter them. They can be combined with other operators, with matrices and with scalars. Operators may be transposed and conjugate-transposed using the usual Julia syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LinearOperator-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#LinearOperators.LinearOperator-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>LinearOperators.LinearOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearOperator(M::AbstractMatrix{T}; symmetric=false, hermitian=false, S = Vector{T}) where {T}</code></pre><p>Construct a linear operator from a dense or sparse matrix. Use the optional keyword arguments to indicate whether the operator is symmetric and/or hermitian. Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/constructors.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LinearOperator-Union{Tuple{I}, Tuple{T}, Tuple{Type{T}, I, I, Bool, Bool, Any}, Tuple{Type{T}, I, I, Bool, Bool, Any, Any}, Tuple{Type{T}, I, I, Bool, Bool, Any, Any, Any}} where {T, I&lt;:Integer}" href="#LinearOperators.LinearOperator-Union{Tuple{I}, Tuple{T}, Tuple{Type{T}, I, I, Bool, Bool, Any}, Tuple{Type{T}, I, I, Bool, Bool, Any, Any}, Tuple{Type{T}, I, I, Bool, Bool, Any, Any, Any}} where {T, I&lt;:Integer}"><code>LinearOperators.LinearOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearOperator(type::Type{T}, nrow, ncol, symmetric, hermitian, prod!,
                [tprod!=nothing, ctprod!=nothing],
                S = Vector{T}) where {T}</code></pre><p>Construct a linear operator from functions where the type is specified as the first argument. Change <code>S</code> to use LinearOperators on GPU. Notice that the linear operator does not enforce the type, so using a wrong type can result in errors. For instance,</p><pre><code class="nohighlight hljs">A = [im 1.0; 0.0 1.0] # Complex matrix
function mulOp!(res, M, v, α, β)
  mul!(res, M, v, α, β)
end
op = LinearOperator(Float64, 2, 2, false, false, 
                    (res, v, α, β) -&gt; mulOp!(res, A, v, α, β), 
                    (res, u, α, β) -&gt; mulOp!(res, transpose(A), u, α, β), 
                    (res, w, α, β) -&gt; mulOp!(res, A&#39;, w, α, β))
Matrix(op) # InexactError</code></pre><p>The error is caused because <code>Matrix(op)</code> tries to create a Float64 matrix with the contents of the complex matrix <code>A</code>.</p><p>Using <code>*</code> may generate a vector that contains <code>NaN</code> values. This can also happen if you use the 3-args <code>mul!</code> function with a preallocated vector such as  <code>Vector{Float64}(undef, n)</code>. To fix this issue you will have to deal with the cases <code>β == 0</code> and <code>β != 0</code> separately:</p><pre><code class="nohighlight hljs">d1 = [2.0; 3.0]
function mulSquareOpDiagonal!(res, d, v, α, β::T) where T
  if β == zero(T)
    res .= α .* d .* v
  else 
    res .= α .* d .* v .+ β .* res
  end
end
op = LinearOperator(Float64, 2, 2, true, true, 
                    (res, v, α, β) -&gt; mulSquareOpDiagonal!(res, d, v, α, β))</code></pre><p>It is possible to create an operator with the 3-args <code>mul!</code>. In this case, using the 5-args <code>mul!</code> will generate storage vectors.</p><pre><code class="nohighlight hljs">A = rand(2, 2)
op = LinearOperator(Float64, 2, 2, false, false, 
                    (res, v) -&gt; mul!(res, A, v),
                    (res, w) -&gt; mul!(res, A&#39;, w))</code></pre><p>The 3-args <code>mul!</code> also works when applying the operator on a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/constructors.jl#L56-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T})}, Tuple{T}, Tuple{LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T}), Any}} where T" href="#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T})}, Tuple{T}, Tuple{LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T}), Any}} where T"><code>LinearOperators.LinearOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearOperator(M::Hermitian{T}, S = Vector{T}) where {T}</code></pre><p>Constructs a linear operator from a Hermitian matrix. If its elements are real, it is also symmetric. Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/constructors.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.SymTridiagonal{T, V} where V&lt;:AbstractVector{T}}, Tuple{T}, Tuple{LinearAlgebra.SymTridiagonal{T, V} where V&lt;:AbstractVector{T}, Any}} where T" href="#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.SymTridiagonal{T, V} where V&lt;:AbstractVector{T}}, Tuple{T}, Tuple{LinearAlgebra.SymTridiagonal{T, V} where V&lt;:AbstractVector{T}, Any}} where T"><code>LinearOperators.LinearOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearOperator(M::SymTridiagonal{T}, S = Vector{T}) where {T}</code></pre><p>Constructs a linear operator from a symmetric tridiagonal matrix. If its elements are real, it is also Hermitian, otherwise complex symmetric. Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/constructors.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Symmetric{T, S} where S&lt;:(AbstractMatrix{&lt;:T})}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S} where S&lt;:(AbstractMatrix{&lt;:T}), Any}} where T&lt;:Real" href="#LinearOperators.LinearOperator-Union{Tuple{LinearAlgebra.Symmetric{T, S} where S&lt;:(AbstractMatrix{&lt;:T})}, Tuple{T}, Tuple{LinearAlgebra.Symmetric{T, S} where S&lt;:(AbstractMatrix{&lt;:T}), Any}} where T&lt;:Real"><code>LinearOperators.LinearOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>LinearOperator(M::Symmetric{T}, S = Vector{T}) where {T &lt;: Real} =</p><p>Construct a linear operator from a symmetric real square matrix <code>M</code>. Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/constructors.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.SpectralGradient" href="#LinearOperators.SpectralGradient"><code>LinearOperators.SpectralGradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Implementation of a spectral gradient quasi-Newton approximation described in</p><p>Birgin, E. G., Martínez, J. M., &amp; Raydan, M. Spectral Projected Gradient Methods: Review and Perspectives. https://doi.org/10.18637/jss.v060.i03</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.SpectralGradient-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:Real, I&lt;:Integer}" href="#LinearOperators.SpectralGradient-Union{Tuple{I}, Tuple{T}, Tuple{T, I}} where {T&lt;:Real, I&lt;:Integer}"><code>LinearOperators.SpectralGradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    SpectralGradient(σ, n)</code></pre><p>Construct a spectral gradient Hessian approximation. The approximation is defined as σI.</p><p><strong>Arguments</strong></p><ul><li><code>σ::Real</code>: initial positive multiple of the identity;</li><li><code>n::Int</code>: operator size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L174-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.TimedLinearOperator-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T" href="#LinearOperators.TimedLinearOperator-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T"><code>LinearOperators.TimedLinearOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimedLinearOperator(op)</code></pre><p>Creates a linear operator instrumented with timers from TimerOutputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/TimedOperators.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opEye" href="#LinearOperators.opEye"><code>LinearOperators.opEye</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>opEye()</code></p><p>Identity operator.</p><pre><code class="nohighlight hljs">opI = opEye()
v = rand(5)
@assert opI * v === v</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opEye-Tuple{DataType, Int64}" href="#LinearOperators.opEye-Tuple{DataType, Int64}"><code>LinearOperators.opEye</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opEye(T, n; S = Vector{T})
opEye(n)</code></pre><p>Identity operator of order <code>n</code> and of data type <code>T</code> (defaults to <code>Float64</code>). Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opEye-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer" href="#LinearOperators.opEye-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer"><code>LinearOperators.opEye</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opEye(T, nrow, ncol; S = Vector{T})
opEye(nrow, ncol)</code></pre><p>Rectangular identity operator of size <code>nrow</code>x<code>ncol</code> and of data type <code>T</code> (defaults to <code>Float64</code>). Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.kron-Tuple{AbstractLinearOperator, AbstractLinearOperator}" href="#Base.kron-Tuple{AbstractLinearOperator, AbstractLinearOperator}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>kron(A, B)</code></p><p>Kronecker tensor product of A and B in linear operator form, if either or both are linear operators. If both A and B are matrices, then <code>Base.kron</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/kron.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!-Tuple{LSR1Operator, AbstractVector, AbstractVector}" href="#Base.push!-Tuple{LSR1Operator, AbstractVector, AbstractVector}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push!(op, s, y)</code></pre><p>Push a new {s,y} pair into a L-SR1 operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L124-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{I}, Tuple{T}, Tuple{LBFGSOperator{T, I, F1, F2, F3}, Vector{T}, Vector{T}}} where {T, I, F1, F2, F3}" href="#Base.push!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{I}, Tuple{T}, Tuple{LBFGSOperator{T, I, F1, F2, F3}, Vector{T}, Vector{T}}} where {T, I, F1, F2, F3}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push!(op, s, y)
push!(op, s, y, Bs)
push!(op, s, y, α, g)
push!(op, s, y, α, g, Bs)</code></pre><p>Push a new {s,y} pair into a L-BFGS operator. The second calling sequence is used for forward updating damping, using the preallocated vector <code>Bs</code>. If the operator is damped, the first call will create <code>Bs</code> and call the second call. The third and fourth calling sequences are used in inverse LBFGS updating in conjunction with damping, where α is the most recent steplength and g the gradient used when solving <code>d=-Hg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L253-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, AbstractLinearOperator}" href="#Base.show-Tuple{IO, AbstractLinearOperator}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">show(io, op)</code></pre><p>Display basic information about a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{AbstractLinearOperator, Integer}" href="#Base.size-Tuple{AbstractLinearOperator, Integer}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">m = size(op, d)</code></pre><p>Return the size of a linear operator along dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{AbstractLinearOperator}" href="#Base.size-Tuple{AbstractLinearOperator}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">m, n = size(op)</code></pre><p>Return the size of a linear operator as a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diag-Union{Tuple{LBFGSOperator{T}}, Tuple{T}} where T" href="#LinearAlgebra.diag-Union{Tuple{LBFGSOperator{T}}, Tuple{T}} where T"><code>LinearAlgebra.diag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diag(op)
diag!(op, d)</code></pre><p>Extract the diagonal of a L-BFGS operator in forward mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L365-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diag-Union{Tuple{LSR1Operator{T}}, Tuple{T}} where T" href="#LinearAlgebra.diag-Union{Tuple{LSR1Operator{T}}, Tuple{T}} where T"><code>LinearAlgebra.diag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diag(op)
diag!(op, d)</code></pre><p>Extract the diagonal of a L-SR1 operator in forward mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ishermitian-Tuple{AbstractLinearOperator}" href="#LinearAlgebra.ishermitian-Tuple{AbstractLinearOperator}"><code>LinearAlgebra.ishermitian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishermitian(op)</code></pre><p>Determine whether the operator is Hermitian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.issymmetric-Tuple{AbstractLinearOperator}" href="#LinearAlgebra.issymmetric-Tuple{AbstractLinearOperator}"><code>LinearAlgebra.issymmetric</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issymmetric(op)</code></pre><p>Determine whether the operator is symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.BlockDiagonalOperator-Tuple" href="#LinearOperators.BlockDiagonalOperator-Tuple"><code>LinearOperators.BlockDiagonalOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockDiagonalOperator(M1, M2, ..., Mn; S = promote_type(storage_type.(M1, M2, ..., Mn)))</code></pre><p>Creates a block-diagonal linear operator:</p><pre><code class="nohighlight hljs">[ M1           ]
[    M2        ]
[       ...    ]
[           Mn ]</code></pre><p>Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L237-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.InverseLBFGSOperator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer" href="#LinearOperators.InverseLBFGSOperator-Union{Tuple{I}, Tuple{DataType, I}} where I&lt;:Integer"><code>LinearOperators.InverseLBFGSOperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InverseLBFGSOperator(T, n, [mem=5; scaling=true])
InverseLBFGSOperator(n, [mem=5; scaling=true])</code></pre><p>Construct a limited-memory BFGS approximation in inverse form. If the type <code>T</code> is omitted, then <code>Float64</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.check_ctranspose-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}" href="#LinearOperators.check_ctranspose-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}"><code>LinearOperators.check_ctranspose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_ctranspose(op)</code></pre><p>Cheap check that the operator and its conjugate transposed are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/utilities.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.check_hermitian-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}" href="#LinearOperators.check_hermitian-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}"><code>LinearOperators.check_hermitian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_hermitian(op)</code></pre><p>Cheap check that the operator is Hermitian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/utilities.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.check_positive_definite-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}" href="#LinearOperators.check_positive_definite-Union{Tuple{AbstractLinearOperator{T}}, Tuple{T}} where T&lt;:Union{AbstractFloat, Complex}"><code>LinearOperators.check_positive_definite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_positive_definite(op; semi=false)</code></pre><p>Cheap check that the operator is positive (semi-)definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/utilities.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.has_args5-Tuple{AbstractLinearOperator}" href="#LinearOperators.has_args5-Tuple{AbstractLinearOperator}"><code>LinearOperators.has_args5</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_args5(op)</code></pre><p>Determine whether the operator can work with the 5-args <code>mul!</code>. If <code>false</code>, storage vectors will be generated at the first call of the 5-args <code>mul!</code>. No additional vectors are generated when using the 3-args <code>mul!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.normest" href="#LinearOperators.normest"><code>LinearOperators.normest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>normest(S) estimates the matrix 2-norm of S. This function is an adaptation of Matlab&#39;s built-in NORMEST. This method allocates.</p><hr/><p>Inputs:   S –- Matrix or LinearOperator type,    tol –-  relative error tol, default(or -1) Machine eps   maxiter –- maximum iteration, default 100</p><p>Returns:   e –- the estimated norm   cnt –- the number of iterations used</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/utilities.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opCholesky-Tuple{AbstractMatrix}" href="#LinearOperators.opCholesky-Tuple{AbstractMatrix}"><code>LinearOperators.opCholesky</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opCholesky(M, [check=false])</code></pre><p>Inverse of a Hermitian and positive definite matrix as a linear operator using its Cholesky factorization.  The factorization is computed only once. The optional <code>check</code> argument will perform cheap hermicity and definiteness checks. This Operator is not in-place when using <code>mul!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/linalg.jl#L34-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opDiagonal-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#LinearOperators.opDiagonal-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>LinearOperators.opDiagonal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opDiagonal(d)</code></pre><p>Diagonal operator with the vector <code>d</code> on its main diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opDiagonal-Union{Tuple{I}, Tuple{T}, Tuple{I, I, AbstractVector{T}}} where {T, I&lt;:Integer}" href="#LinearOperators.opDiagonal-Union{Tuple{I}, Tuple{T}, Tuple{I, I, AbstractVector{T}}} where {T, I&lt;:Integer}"><code>LinearOperators.opDiagonal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opDiagonal(nrow, ncol, d)</code></pre><p>Rectangular diagonal operator of size <code>nrow</code>-by-<code>ncol</code> with the vector <code>d</code> on its main diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opExtension-Union{Tuple{I}, Tuple{AbstractVector{I}, I}} where I&lt;:Integer" href="#LinearOperators.opExtension-Union{Tuple{I}, Tuple{AbstractVector{I}, I}} where I&lt;:Integer"><code>LinearOperators.opExtension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Z = opExtension(I, ncol)
Z = opExtension(:, ncol)</code></pre><p>Creates a LinearOperator extending a vector of size <code>length(I)</code> to size <code>ncol</code>, where the position of the elements on the new vector are given by the indices <code>I</code>. The operation <code>w = Z * v</code> is equivalent to <code>w = zeros(ncol); w[I] = v</code>.</p><pre><code class="nohighlight hljs">Z = opExtension(k, ncol)</code></pre><p>Alias for <code>opExtension([k], ncol)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L203-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opHermitian-Tuple{AbstractMatrix}" href="#LinearOperators.opHermitian-Tuple{AbstractMatrix}"><code>LinearOperators.opHermitian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opHermitian(A)</code></pre><p>A symmetric/hermitian operator based on a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/linalg.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opHermitian-Union{Tuple{T}, Tuple{S}, Tuple{AbstractVector{S}, AbstractMatrix{T}}} where {S, T}" href="#LinearOperators.opHermitian-Union{Tuple{T}, Tuple{S}, Tuple{AbstractVector{S}, AbstractMatrix{T}}} where {S, T}"><code>LinearOperators.opHermitian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opHermitian(d, A)</code></pre><p>A symmetric/hermitian operator based on the diagonal <code>d</code> and lower triangle of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/linalg.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opHouseholder-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#LinearOperators.opHouseholder-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>LinearOperators.opHouseholder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opHouseholder(h)</code></pre><p>Apply a Householder transformation defined by the vector <code>h</code>. The result is <code>x -&gt; (I - 2 h hᵀ) x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/linalg.jl#L85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opInverse-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#LinearOperators.opInverse-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>LinearOperators.opInverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opInverse(M; symm=false, herm=false)</code></pre><p>Inverse of a matrix as a linear operator using <code>\</code>. Useful for triangular matrices. Note that each application of this operator applies <code>\</code>. This Operator is not in-place when using <code>mul!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/linalg.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opLDL" href="#LinearOperators.opLDL"><code>LinearOperators.opLDL</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opLDL(M, [check=false])</code></pre><p>Inverse of a symmetric matrix as a linear operator using its LDLᵀ factorization if it exists. The factorization is computed only once. The optional <code>check</code> argument will perform a cheap hermicity check.</p><p>If M is sparse and real, then only the upper triangle should be stored in order to use  <a href="https://github.com/JuliaSmoothOptimizers/LDLFactorizations.jl"><code>LDLFactorizations.jl</code></a>:</p><pre><code class="nohighlight hljs">using LDLFactorizations
triu!(M)
opLDL(Symmetric(M, :U))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/linalg.jl#L60-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opOnes-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer" href="#LinearOperators.opOnes-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer"><code>LinearOperators.opOnes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opOnes(T, nrow, ncol; S = Vector{T})
opOnes(nrow, ncol)</code></pre><p>Operator of all ones of size <code>nrow</code>-by-<code>ncol</code> of data type <code>T</code> (defaults to <code>Float64</code>). Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L87-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opRestriction-Union{Tuple{I}, Tuple{AbstractVector{I}, I}} where I&lt;:Integer" href="#LinearOperators.opRestriction-Union{Tuple{I}, Tuple{AbstractVector{I}, I}} where I&lt;:Integer"><code>LinearOperators.opRestriction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Z = opRestriction(I, ncol)
Z = opRestriction(:, ncol)</code></pre><p>Creates a LinearOperator restricting a <code>ncol</code>-sized vector to indices <code>I</code>. The operation <code>Z * v</code> is equivalent to <code>v[I]</code>. <code>I</code> can be <code>:</code>.</p><pre><code class="nohighlight hljs">Z = opRestriction(k, ncol)</code></pre><p>Alias for <code>opRestriction([k], ncol)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.opZeros-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer" href="#LinearOperators.opZeros-Union{Tuple{I}, Tuple{DataType, I, I}} where I&lt;:Integer"><code>LinearOperators.opZeros</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opZeros(T, nrow, ncol; S = Vector{T})
opZeros(nrow, ncol)</code></pre><p>Zero operator of size <code>nrow</code>-by-<code>ncol</code>, of data type <code>T</code> (defaults to <code>Float64</code>). Change <code>S</code> to use LinearOperators on GPU.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/special-operators.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.reset!-Tuple{AbstractLinearOperator}" href="#LinearOperators.reset!-Tuple{AbstractLinearOperator}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>reset!(op)</p><p>Reset the product counters of a linear operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/abstract.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.reset!-Tuple{LBFGSOperator}" href="#LinearOperators.reset!-Tuple{LBFGSOperator}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(op)</code></pre><p>Resets the LBFGS data of the given operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L415-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.reset!-Tuple{LSR1Operator}" href="#LinearOperators.reset!-Tuple{LSR1Operator}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(op)</code></pre><p>Resets the LSR1 data of the given operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L234-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.reset!-Union{Tuple{AbstractDiagonalQuasiNewtonOperator{T}}, Tuple{T}} where T&lt;:Real" href="#LinearOperators.reset!-Union{Tuple{AbstractDiagonalQuasiNewtonOperator{T}}, Tuple{T}} where T&lt;:Real"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(op::AbstractDiagonalQuasiNewtonOperator)</code></pre><p>Reset the diagonal data of the given operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/DiagonalHessianApproximation.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.reset!-Union{Tuple{I}, Tuple{T}, Tuple{LinearOperators.LBFGSData{T, I}, Bool}} where {T, I&lt;:Integer}" href="#LinearOperators.reset!-Union{Tuple{I}, Tuple{T}, Tuple{LinearOperators.LBFGSData{T, I}, Bool}} where {T, I&lt;:Integer}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(data)</code></pre><p>Resets the given LBFGS data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lbfgs.jl#L395-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.reset!-Union{Tuple{LinearOperators.LSR1Data{T, I}}, Tuple{I}, Tuple{T}} where {T, I&lt;:Integer}" href="#LinearOperators.reset!-Union{Tuple{LinearOperators.LSR1Data{T, I}}, Tuple{I}, Tuple{T}} where {T, I&lt;:Integer}"><code>LinearOperators.reset!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset!(data)</code></pre><p>Reset the given LSR1 data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/lsr1.jl#L217-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearOperators.solve_shifted_system!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{I}, Tuple{T}, Tuple{AbstractVector{T}, LBFGSOperator{T, I, F1, F2, F3}, AbstractVector{T}, T}} where {T, I, F1, F2, F3}" href="#LinearOperators.solve_shifted_system!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{I}, Tuple{T}, Tuple{AbstractVector{T}, LBFGSOperator{T, I, F1, F2, F3}, AbstractVector{T}, T}} where {T, I, F1, F2, F3}"><code>LinearOperators.solve_shifted_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>solve<em>shifted</em>system!(x, B,  b, σ)</p><p>Solve linear system (B + σI) x = b, where B is a forward L-BFGS operator and σ ≥ 0.</p><p><strong>Parameters</strong></p><ul><li><code>x::AbstractVector{T}</code>: preallocated vector of length n that is used to store the solution x.</li><li><code>B::LBFGSOperator</code>: forward L-BFGS operator that models a matrix of size n x n.</li><li><code>b::AbstractVector{T}</code>: right-hand side vector of length n.</li><li><code>σ::T</code>: nonnegative shift.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::AbstractVector{T}</code>: solution vector <code>x</code> of length n.</li></ul><p><strong>Method</strong></p><p>The method uses a two-loop recursion-like approach with modifications to handle the shift <code>σ</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Random

# Problem setup
n = 100  # size of the problem
mem = 10   # L-BFGS memory size
scaling = true  # enable scaling

# Create an L-BFGS operator
B = LBFGSOperator(n, mem = mem, scaling = scaling)

# Add random {s, y} pairs to the L-BFGS operator
for _ = 1:10
    s = rand(n)   
    y = rand(n)   
    push!(B, s, y)  # Add the {s, y} pair to B
end

# Prepare vectors for the system
x = zeros(n)   # Preallocated solution vector
b = rand(n)        # Right-hand side vector
σ = 0.1            # Small shift value

# Solve the shifted system
result = solve_shifted_system!(x, B, b, σ)

# Check that the solution is close enough (residual test)
@assert norm(B * x + σ * x - b) / norm(b) &lt; 1e-8</code></pre><p><strong>References</strong></p><p>Erway, J. B., Jain, V., &amp; Marcia, R. F. Shifted L-BFGS Systems. Optimization Methods and Software, 29(5), pp. 992-1004, 2014.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSmoothOptimizers/LinearOperators.jl/blob/475e24c42440c114474a967b446d2ed3cb28731b/src/utilities.jl#L151-L206">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 23 November 2024 22:33">Saturday 23 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
